const fs = require('fs');
const path = require('path');
const archiver = require('archiver');

const projectRoot = path.join(__dirname, '..');
const distPath = path.join(projectRoot, 'dist');
const outputPath = path.join(projectRoot, 'tableau-wdc-dynamic-v2.taco');

async function packageWDC() {
  console.log('📦 Creating WDC package...');
  
  // Check if dist exists
  if (!fs.existsSync(distPath)) {
    console.error('❌ dist folder not found. Run "npm run build" first.');
    process.exit(1);
  }

  // Validate required files
  const requiredFiles = [
    path.join(distPath, 'connector.json'),
    path.join(distPath, 'app', 'index.html'),
    path.join(distPath, 'app', 'index.js'),
    path.join(distPath, 'app', 'connector.json'),
    path.join(distPath, 'handlers', 'connector.json')
  ];

  const missingFiles = requiredFiles.filter(file => !fs.existsSync(file));
  if (missingFiles.length > 0) {
    console.error('❌ Missing required files:');
    missingFiles.forEach(file => console.error(`  - ${path.relative(distPath, file)}`));
    process.exit(1);
  }

  // Remove existing package
  if (fs.existsSync(outputPath)) {
    fs.unlinkSync(outputPath);
  }

  return new Promise((resolve, reject) => {
    // Create archive
    const output = fs.createWriteStream(outputPath);
    const archive = archiver('zip', { 
      zlib: { level: 9 },
      comment: 'Dynamic Report WDC - Generated by custom build scripts'
    });

    output.on('close', () => {
      const sizeKB = Math.round(archive.pointer() / 1024);
      console.log(`✅ Package created: ${path.basename(outputPath)} (${sizeKB} KB)`);
      console.log(`📁 Location: ${outputPath}`);
      resolve();
    });

    archive.on('error', (err) => {
      console.error('❌ Packaging failed:', err);
      reject(err);
    });

    archive.on('warning', (err) => {
      console.warn('⚠️ Packaging warning:', err);
    });

    archive.pipe(output);

    // Add dist contents maintaining the dist/ structure
    archive.directory(distPath, 'dist');
    
    // Add XML configuration files to root
    const xmlFiles = ['manifest.xml', 'connection-fields.xml', 'connection-metadata.xml'];
    xmlFiles.forEach(fileName => {
      const filePath = path.join(projectRoot, fileName);
      if (fs.existsSync(filePath)) {
        archive.file(filePath, { name: fileName });
      }
    });
    
    // Add connector source directory
    const connectorSrcPath = path.join(projectRoot, 'connector');
    if (fs.existsSync(connectorSrcPath)) {
      archive.directory(connectorSrcPath, 'connector');
    }
    
    // Add META-INF directory
    const metaInfPath = path.join(projectRoot, 'META-INF');
    if (fs.existsSync(metaInfPath)) {
      archive.directory(metaInfPath, 'META-INF');
    }

    // Show what's being packaged
    console.log('📋 Including files:');
    const files = getAllFiles(distPath);
    files.forEach(file => {
      const relativePath = path.relative(distPath, file);
      console.log(`  ✓ dist/${relativePath}`);
    });
    
    // Show XML files
    xmlFiles.forEach(fileName => {
      const filePath = path.join(projectRoot, fileName);
      if (fs.existsSync(filePath)) {
        console.log(`  ✓ ${fileName}`);
      }
    });
    
    // Show connector source
    if (fs.existsSync(connectorSrcPath)) {
      console.log(`  ✓ connector/connector.json`);
      console.log(`  ✓ connector/package.json`);
    }
    
    if (fs.existsSync(metaInfPath)) {
      console.log(`  ✓ META-INF/MANIFEST.MF`);
    }

    archive.finalize();
  });
}

function getAllFiles(dir) {
  const files = [];
  const items = fs.readdirSync(dir);
  
  for (const item of items) {
    const fullPath = path.join(dir, item);
    if (fs.statSync(fullPath).isDirectory()) {
      files.push(...getAllFiles(fullPath));
    } else {
      files.push(fullPath);
    }
  }
  
  return files;
}

// Run if called directly
if (require.main === module) {
  packageWDC().catch(console.error);
}

module.exports = { packageWDC };
